"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class AsyncPromisifier{exec(e){if(1===e.length)return new Promise((t,s)=>{e(e=>{e instanceof Error?s(e):t(e)})});try{return Promise.resolve(e())}catch(e){return Promise.reject(e)}}}class TimeoutError extends Error{constructor(e,t,s){super(e),this.timeoutMs=s}}class TimeoutPromisifier{wrap(e,t){if(t<=0)return e;const s=Date.now();let i=null;const r=new Promise((e,r)=>{i=setTimeout(()=>{const e=Date.now()-s;r(new TimeoutError(`Async task timeout exceeded! Elapsed: ${e}, timeout: ${t}ms.`,e,t))},t)});return e.catch(()=>{clearTimeout(i)}),Promise.race([e,r]).then(e=>(clearTimeout(i),e))}}function mergeConfig(e,t){if(!t||"object"!=typeof t)return e;if("object"==typeof e.timeoutMs&&"object"==typeof t.timeoutMs)for(const s of["it","before","beforeEach","after","afterEach"])"number"==typeof t.timeoutMs[s]&&(e.timeoutMs[s]=t.timeoutMs[s]);else void 0!==t.timeoutMs&&(e.timeoutMs=t.timeoutMs);return e.stopOnFirstFail!==t.stopOnFirstFail&&(e.stopOnFirstFail=t.stopOnFirstFail),e}const DefaultTestRunnerConfig={timeoutMs:100,stopOnFirstFail:!1};function union(e,t){if(!e)return t||[];if(!t)return e;for(const s of t)-1===e.indexOf(s)&&e.push(s);return e}function without(e,t){if(!e)return[];const s=e.indexOf(t);return-1!==s&&e.splice(s,1),e}class SimpleEventEmitter{constructor(){this.onListeners={},this.onceListeners={}}on(e,t){this.onListeners[e]=union(this.onListeners[e],[t])}once(e,t){this.onceListeners[e]=union(this.onceListeners[e],[t])}off(e,t){this.onListeners[e]=without(this.onListeners[e],t),this.onceListeners[e]=without(this.onceListeners[e],t)}emit(e,...t){if(this.onListeners[e])for(const s of this.onListeners[e])s.call(null,...t);if(this.onceListeners[e]&&this.onceListeners[e].length>0){for(const s of this.onceListeners[e])s.call(null,...t);this.onceListeners[e]=[]}}emitAndWaitForCompletion(e,...t){const s=[];if(this.onListeners[e])for(const i of this.onListeners[e])try{s.push(Promise.resolve(i.call(null,...t)))}catch(e){s.push(Promise.reject(e))}if(this.onceListeners[e]&&this.onceListeners[e].length>0){for(const i of this.onceListeners[e])try{s.push(Promise.resolve(i.call(null,...t)))}catch(e){s.push(Promise.reject(e))}this.onceListeners[e]=[]}return Promise.all(s).then(e=>{})}}const QueueStackTypes=["before","beforeEach","after","afterEach"];class TestRunner{constructor(e,t=new SimpleEventEmitter){this.asyncPromisifier=new AsyncPromisifier,this.timeoutPromisifier=new TimeoutPromisifier,this.testQueueStack=[],this.queueStacks={before:[[]],beforeEach:[[]],after:[[]],afterEach:[[]]},this.hasAnOnlyDescribe=!1,this.hasAnOnlyIt=!1,this.currentTest=null,this.testRunCancelled=!1,this.describe=(e,t)=>{this.throwIfTestInProgress("describe"),this.pushToCurrentTestQueue("describe",e,t)},this.describeOnly=(e,t)=>{this.throwIfTestInProgress("describe.only"),this.hasAnOnlyDescribe=!0,this.pushToCurrentTestQueue("describe",e,t,!0)},this.it=(e,t,s)=>{this.throwIfTestInProgress("it"),this.pushToCurrentTestQueue("it",e,t,!1,s?s.timeoutMs:void 0)},this.itOnly=(e,t,s)=>{this.throwIfTestInProgress("it.only"),this.hasAnOnlyIt=!0,this.pushToCurrentTestQueue("it",e,t,!0,s?s.timeoutMs:void 0)},this.runNextTestQueue=()=>{if(0===this.testQueueStack.length)return Promise.resolve();const e=this.testQueueStack.shift();let t=!1,s=Promise.resolve();for(let i=0;i<e.tests.length;i++){const r=e.tests[i];r.absoluteFilePath!==this.currentlyExecutingFilePath&&(this.currentlyExecutingFilePath=r.absoluteFilePath,this.eventEmitter.emit("activeFileChanged",this.currentlyExecutingFilePath)),s=s.then(()=>{if(!this.testRunCancelled)return"describe"===r.type?this.evaluateDescribe(e,r):this.evaluateTest(e,r).then(e=>{t=e})})}return s.then(()=>{if(t)return this.evaluateQueueWithTimeout("after")})},this.throwIfTestInProgress=e=>{if(this.currentTest)throw new Error(`Cannot add an ${e} block while executing a test!`)},this.resetRunResults=()=>{this.runResults={elapsedTimeMs:0,totalTests:0,totalSuccesses:0,totalFailures:0,totalTimeouts:0,failureInfo:[],timeoutInfo:[]}},this.config=mergeConfig(DefaultTestRunnerConfig,e),this.eventEmitter=t,this.it.only=this.itOnly,this.describe.only=this.describeOnly,this.resetRunResults()}setCurrentFile(e){this.lastFilePathSet=e}on(e,t){this.eventEmitter.on(e,t)}once(e,t){this.eventEmitter.once(e,t)}off(e,t){this.eventEmitter.off(e,t)}before(e){this.throwIfTestInProgress("before"),this.queueStacks.before[0].push(e)}beforeEach(e){this.throwIfTestInProgress("beforeEach"),this.queueStacks.beforeEach[0].push(e)}after(e){this.throwIfTestInProgress("after"),this.queueStacks.after[0].push(e)}afterEach(e){this.throwIfTestInProgress("afterEach"),this.queueStacks.afterEach[0].push(e)}run(){if(this.currentRun)throw new Error("Can't start a test run if one is already in progress!");return this.currentRun=this.runNextTestQueue().then(()=>{const e=this.runResults;return this.resetRunResults(),e}).finally(()=>{this.currentRun=null}),this.currentRun}getCurrentTestInfo(){if(!this.currentTest)throw new Error("Can't obtain TestInfo if not actively in a test!");return this.currentTest}reset(){if(this.currentRun)throw new Error("Can't reset if a test run is already in progress!");this.resetRunResults(),this.testRunCancelled=!1,this.hasAnOnlyIt=!1,this.hasAnOnlyDescribe=!1,this.testQueueStack=[];for(const e of QueueStackTypes)this.queueStacks[e]=[[]]}cancel(){if(this.currentRun)return this.testRunCancelled=!0,this.currentRun.then(e=>(this.reset(),e))}pushToCurrentTestQueue(e,t,s,i,r){if(0===this.testQueueStack.length){const e={titleChain:[],tests:[],evaluatedBefores:!1};this.testQueueStack.push(e)}const n=this.testQueueStack[this.testQueueStack.length-1],o={title:t,type:e,callback:s,absoluteFilePath:this.lastFilePathSet};i&&(o.only=i),r>0&&(o.timeoutMs=r),n.tests.push(o)}evaluateDescribe(e,t){if(this.hasAnOnlyDescribe&&!t.only)return Promise.resolve();this.testQueueStack.push({titleChain:[].concat(e.titleChain,t.title),tests:[],evaluatedBefores:!1});for(const e of QueueStackTypes)this.queueStacks[e].push([]);this.eventEmitter.emit("beforeDescribe",t.title);const s=Date.now();return this.asyncPromisifier.exec(t.callback).then(this.runNextTestQueue).then(()=>{for(const e of QueueStackTypes)this.queueStacks[e].shift();const e=Date.now()-s;this.eventEmitter.emit("afterDescribe",t.title,e)})}evaluateTest(e,t){if(this.hasAnOnlyIt&&!t.only)return Promise.resolve(!1);let s=Promise.resolve();return e.evaluatedBefores||(e.evaluatedBefores=!0,s=s.then(()=>this.evaluateQueueWithTimeout("before"))),s.then(()=>this.evaluateQueueWithTimeout("beforeEach").then(()=>{this.eventEmitter.emit("beforeTest",t.title);const s=Date.now();this.currentTest=t;const i=t.timeoutMs>=0?t.timeoutMs:this.getTimeoutValue("it");return this.timeoutPromisifier.wrap(this.asyncPromisifier.exec(t.callback),i).then(()=>this.eventEmitter.emitAndWaitForCompletion("beforeTestSuccess",t.title)).then(()=>{this.runResults.totalSuccesses++;const e=Date.now()-s;this.eventEmitter.emit("testSuccess",t.title,e)}).catch(i=>{i instanceof TimeoutError?(this.runResults.totalTimeouts++,this.runResults.timeoutInfo.push({describeChain:e.titleChain,title:t.title,elapsedMs:i.elapsedMs,timeoutMs:i.timeoutMs}),this.eventEmitter.emit("testTimeout",t.title,i.elapsedMs,i.timeoutMs)):(this.runResults.totalFailures++,this.runResults.failureInfo.push({describeChain:e.titleChain,title:t.title,error:i}),this.eventEmitter.emit("testFail",t.title,i,Date.now()-s)),this.config.stopOnFirstFail&&(this.testRunCancelled=!0)}).then(()=>this.evaluateQueueWithTimeout("afterEach")).finally(()=>{this.runResults.totalTests++,this.currentTest=null})})).then(()=>!0)}evaluateQueueWithTimeout(e){return this.timeoutPromisifier.wrap(this.evaluateQueue(e),this.getTimeoutValue(e))}evaluateQueue(e){const t=this.queueStacks[e];let s=Promise.resolve();if("before"===e||"beforeEach"===e)for(let e=0;e<t.length;e++){const i=t[e];for(let e=0;e<i.length;e++)s=s.then(()=>this.asyncPromisifier.exec(i[e]))}else for(let e=t.length-1;e>=0;e--){const i=t[e];for(let e=i.length-1;e>=0;e--)s=s.then(()=>this.asyncPromisifier.exec(i[e]))}return s}getTimeoutValue(e){return"number"==typeof this.config.timeoutMs?this.config.timeoutMs:this.config.timeoutMs[e]}}exports.TestRunner=TestRunner;
