{"version":3,"file":"umbra-test-runner.min.js","sources":["../src/Async/AsyncPromisifier.ts","../src/Async/TimeoutPromisifier.ts","../src/Config/DefaultTestRunnerConfig.ts","../src/EventEmitter/SimpleEventEmitter.ts","../src/TestRunner.ts","../src/Config/TestRunnerConfig.ts"],"sourcesContent":["interface AsyncCallback<T> {\n    (done?: (result: T) => void): void;\n}\n\ninterface SyncCallback<T> {\n    (): T;\n}\n\ninterface PromiseCallback<T> {\n    (): Promise<T>;\n}\n\n/**\n * A class that massages synchronous and some async functions into promises. Expects very specific function signatures.\n */\nclass AsyncPromisifier {\n\n    /**\n     * Takes a function and executes it as a Promise.\n     *\n     * Supports:\n     *  - Promises\n     *  - \"done\" callback\n     *  - sync returns\n     *\n     * @param {(done) => any} fn\n     * @returns {Promise<T>}\n     */\n    exec<T>(fn: SyncCallback<T> | AsyncCallback<T> | PromiseCallback<T>): Promise<T> {\n\n        /*\n         * 2nd param is \"done\" -- if the user fn has exactly two params then it is expected that they are using a\n         * classic asynchronous function and will call \"done\" when complete.\n         */\n        if (fn.length === 1) {\n            return new Promise((resolve, reject) => {\n                (<AsyncCallback<T>> fn)((result) => {\n                    if (result instanceof Error) {\n                        reject(result);\n                    } else {\n                        resolve(result);\n                    }\n                });\n            });\n        } else {\n            try {\n                return Promise.resolve((<SyncCallback<T>> fn)());\n            } catch (e) {\n                return Promise.reject(e);\n            }\n        }\n    }\n}\n\nexport { AsyncPromisifier, AsyncCallback, SyncCallback, PromiseCallback };\n","/**\r\n * Internal error type for differentiating timeouts from other promise failures.\r\n */\r\nclass TimeoutError extends Error {\r\n    public elapsedMs: number;\r\n    public timeoutMs: number;\r\n\r\n    constructor(message: string, elapsedMs: number, timeoutMs: number) {\r\n        super(message);\r\n        this.timeoutMs = timeoutMs;\r\n    }\r\n}\r\n\r\n/**\r\n * A simple promise wrapper, which enables promises to \"timeout\". It does *NOT* actually manipulate or otherwise\r\n * interrupt long-running tasks, but rather simply ignores their result if they eventually do complete.\r\n */\r\nclass TimeoutPromisifier {\r\n\r\n    /**\r\n     * Wraps the Promise in another Promise, which will resolve/reject based on the former, or if a given amount of time\r\n     * has passed.\r\n     *\r\n     * @param promise\r\n     * @param timeoutMs\r\n     * @return A new promise, which will resolve if the given promise resolves, or reject if the timeout occurs first.\r\n     */\r\n    wrap<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {\r\n        if (timeoutMs <= 0) {\r\n            return promise;\r\n        }\r\n\r\n        const startTime = Date.now();\r\n        let timerId = null;\r\n        const timeoutPromise = new Promise((resolve, reject) => {\r\n            timerId = setTimeout(() => {\r\n                const elapsedMs = Date.now() - startTime;\r\n                reject(new TimeoutError(`Async task timeout exceeded! Elapsed: ${elapsedMs}, timeout: ${timeoutMs}ms.`, elapsedMs, timeoutMs));\r\n            }, timeoutMs);\r\n        });\r\n\r\n        promise.catch(() => {\r\n            clearTimeout(timerId);\r\n        });\r\n\r\n        // timeoutPromise will never resolve, thus we can safely assume that the result is the original one.\r\n        return Promise.race([promise, timeoutPromise]).then((result: unknown) => {\r\n            clearTimeout(timerId);\r\n            return result as T;\r\n        });\r\n    }\r\n\r\n}\r\n\r\nexport {TimeoutError, TimeoutPromisifier};\r\n","import {TestRunnerConfig} from \"./TestRunnerConfig\";\n\n/**\n * Default configuration to be used if the user does not explicitly set configuration.\n */\nconst DefaultTestRunnerConfig: TestRunnerConfig = {\n    timeoutMs: 100,\n    stopOnFirstFail: false\n};\n\nexport {DefaultTestRunnerConfig};\n","type EventArgs<EventMap, Event extends keyof EventMap> = EventMap[Event] extends any[] ? EventMap[Event] : [EventMap[Event]];\ntype EventCallback<EventMap, Event extends keyof EventMap> = (...args: EventArgs<EventMap, Event>) => void;\n\n/**\n * Simple array union with automatic creation if the arrays don't exist. This is a nice optimization which\n * enables the event emitter to lazy-instantiate event callback arrays.\n *\n * @param arrayA\n * @param arrayB\n * @return arrayA, modified to include all items from arrayB that weren't already in arrayA. If arrayA doesn't exist,\n *         an empty array is returned.\n */\nfunction union<T>(arrayA: T[], arrayB: T[]): T[] {\n    if (!arrayA) {\n        return arrayB ? arrayB : [];\n    }\n\n    if (!arrayB) {\n        return arrayA;\n    }\n\n    for (const item of arrayB) {\n        if (arrayA.indexOf(item) === -1) {\n            arrayA.push(item);\n        }\n    }\n\n    return arrayA;\n}\n\n/**\n * Simple array item removal with automatic creation if the array doesn't exist. This is a nice optimization which\n * enables the event emitter to lazy-instantiate event callback arrays.\n *\n * DOES NOT REMOVE DUPLICATE VALUES!\n *\n * @param array - The array from which to remove an item.\n * @param item - The item to remove from the given array.\n * @return The original array, modified to remove the item if it existed. If the array doesn't exist, an empty array\n *         is returned.\n */\nfunction without<T>(array: T[], item: T): T[] {\n    if (!array) {\n        return [];\n    }\n\n    const indexOfItem = array.indexOf(item);\n    if (indexOfItem !== -1) {\n        array.splice(indexOfItem, 1);\n    }\n\n    return array;\n}\n\n/**\n * A ridiculously simple event emitter with typesafety.\n *\n * TODO: Maybe opensource this under its own package in the future.\n */\nclass SimpleEventEmitter<EventMap> {\n\n    // All event arrays are dynamically filled when calling on/onc.\n    private readonly onListeners: { [Event in keyof EventMap]?: EventCallback<EventMap, Event>[] } = {};\n    private readonly onceListeners: { [Event in keyof EventMap]?: EventCallback<EventMap, Event>[] } = {};\n\n    on<Event extends keyof EventMap>(event: Event, callback: EventCallback<EventMap, Event>): void {\n        (this.onListeners[event]) = union(this.onListeners[event], [callback]);\n    }\n\n    once<Event extends keyof EventMap>(event: Event, callback: EventCallback<EventMap, Event>): void {\n        this.onceListeners[event] = union(this.onceListeners[event], [callback]);\n    }\n\n    off<Event extends keyof EventMap>(event: Event, callback: EventCallback<EventMap, Event>): void {\n        this.onListeners[event] = without(this.onListeners[event], callback);\n        this.onceListeners[event] = without(this.onceListeners[event], callback);\n    }\n\n    emit<Event extends keyof EventMap>(event: Event, ...args: EventArgs<EventMap, Event>): void {\n        if (this.onListeners[event]) {\n            for (const callback of this.onListeners[event]) {\n                (callback as any).call(null, ...args);\n            }\n        }\n\n        if (this.onceListeners[event] && this.onceListeners[event].length > 0) {\n            for (const callback of this.onceListeners[event]) {\n                (callback as any).call(null, ...args);\n            }\n\n            this.onceListeners[event] = [];\n        }\n    }\n\n    /**\n     * Evaluates each function synchronously, but waits for all to asynchronously complete before returning.\n     *\n     * TODO: Find a better name for this.\n     *\n     * @param event - The event to emit.\n     * @param args - All args to be emitted for the event.\n     */\n    emitAndWaitForCompletion<Event extends keyof EventMap>(event: Event, ...args: EventArgs<EventMap, Event>): Promise<void> {\n        const promises: Promise<void>[] = [];\n        if (this.onListeners[event]) {\n            for (const callback of this.onListeners[event]) {\n                try {\n                    promises.push(Promise.resolve((callback as any).call(null, ...args)));\n                } catch (e) {\n                    promises.push(Promise.reject(e));\n                }\n            }\n        }\n\n        if (this.onceListeners[event] && this.onceListeners[event].length > 0) {\n            for (const callback of this.onceListeners[event]) {\n                try {\n                    promises.push(Promise.resolve((callback as any).call(null, ...args)));\n                } catch (e) {\n                    promises.push(Promise.reject(e));\n                }\n            }\n\n            this.onceListeners[event] = [];\n        }\n\n        return Promise.all(promises).then((results) => {\n            // Intentionally blank, as we want to swallow all actual \"valid\" values.\n            return;\n        });\n    }\n}\n\nexport {EventArgs, EventCallback, SimpleEventEmitter, union, without};\n","import {EventMap} from \"./EventMap\";\r\nimport {TestInfo} from \"./TestInfo\";\r\nimport {RunResults} from \"./RunResults\";\r\nimport {AsyncPromisifier} from \"./Async/AsyncPromisifier\";\r\nimport {TimeoutError, TimeoutPromisifier} from \"./Async/TimeoutPromisifier\";\r\nimport {mergeConfig, TestRunnerConfig, TimeoutConfig} from \"./Config/TestRunnerConfig\";\r\nimport {DefaultTestRunnerConfig} from \"./Config/DefaultTestRunnerConfig\";\r\nimport {ItOptions} from \"./Config/ItOptions\";\r\nimport {EventCallback, SimpleEventEmitter} from \"./EventEmitter/SimpleEventEmitter\";\r\n\r\ninterface TestEntry extends TestInfo {\r\n    type: \"describe\" | \"it\";\r\n    absoluteFilePath: string | undefined;\r\n}\r\n\r\ninterface TestQueue {\r\n    titleChain: string[];\r\n    tests: TestEntry[];\r\n    evaluatedBefores: boolean;\r\n}\r\n\r\ntype QueueStackType = \"before\" | \"beforeEach\" | \"after\" | \"afterEach\";\r\nconst QueueStackTypes = [\"before\", \"beforeEach\", \"after\", \"afterEach\"];\r\n\r\ninterface ItWithSubMethods {\r\n    (title: string, execBlock: (done?: (result?: Error | any) => void) => Promise<Error | any> | any, options?: Partial<ItOptions>): void;\r\n\r\n    only(title: string, execBlock: (done?: (result?: Error | any) => void) => Promise<Error | any> | any, options?: Partial<ItOptions>);\r\n}\r\n\r\ninterface DescribeWithSubMethods {\r\n    (title: string, execBlock: (done?: (result?: Error | any) => void) => Promise<Error | any> | any): void;\r\n\r\n    only(title: string, execBlock: (done?: (result?: Error | any) => void) => Promise<Error | any> | any);\r\n}\r\n\r\n/**\r\n * before -> beforeEach -> beforeHook -> it -> afterHook -> afterEach -> after\r\n */\r\nclass TestRunner {\r\n\r\n    private readonly asyncPromisifier = new AsyncPromisifier();\r\n    private readonly timeoutPromisifier = new TimeoutPromisifier();\r\n    private readonly eventEmitter: SimpleEventEmitter<EventMap>;\r\n\r\n    private readonly config: TestRunnerConfig;\r\n\r\n    private testQueueStack: TestQueue[] = [];\r\n    private queueStacks: { [key: string]: (() => void)[][] } = {\r\n        \"before\": [[]],\r\n        \"beforeEach\": [[]],\r\n        \"after\": [[]],\r\n        \"afterEach\": [[]]\r\n    };\r\n\r\n    private hasAnOnlyDescribe: boolean = false;\r\n    private hasAnOnlyIt: boolean = false;\r\n    private currentTest: TestEntry | null = null;\r\n    private testRunCancelled: boolean = false;\r\n\r\n    private currentlyExecutingFilePath: string;\r\n    private lastFilePathSet: string;\r\n\r\n    private currentRun: Promise<RunResults>;\r\n    private runResults: RunResults;\r\n\r\n    constructor(config?: TestRunnerConfig, eventEmitter = new SimpleEventEmitter<EventMap>()) {\r\n        this.config = mergeConfig(DefaultTestRunnerConfig, config);\r\n        this.eventEmitter = eventEmitter;\r\n\r\n        this.it.only = this.itOnly;\r\n        this.describe.only = this.describeOnly;\r\n\r\n        this.resetRunResults();\r\n    }\r\n\r\n    /**\r\n     * Sets the current file name for all subsequent calls to describe/it/etc. This is used for logging where tests\r\n     * are sourced from.\r\n     */\r\n    setCurrentFile(absolutePath: string): void {\r\n        this.lastFilePathSet = absolutePath;\r\n    }\r\n\r\n    on<Event extends keyof EventMap>(event: Event, callback: EventCallback<EventMap, Event>): void {\r\n        this.eventEmitter.on(event, callback);\r\n    }\r\n\r\n    once<Event extends keyof EventMap>(event: Event, callback: EventCallback<EventMap, Event>): void {\r\n        this.eventEmitter.once(event, callback);\r\n    }\r\n\r\n    off<Event extends keyof EventMap>(event: Event, callback: EventCallback<EventMap, Event>): void {\r\n        this.eventEmitter.off(event, callback);\r\n    }\r\n\r\n    // This madness is needed to support function/object hybrids, which is remarkably useful but obnoxious in TS.\r\n    readonly describe: DescribeWithSubMethods = ((title: string, execBlock: () => void) => {\r\n        this.throwIfTestInProgress(\"describe\");\r\n        this.pushToCurrentTestQueue(\"describe\", title, execBlock);\r\n    }) as DescribeWithSubMethods;\r\n\r\n    private describeOnly = (title: string, execBlock: (done?: (result?: Error | any) => void) => Promise<Error | any> | any): void => {\r\n        this.throwIfTestInProgress(\"describe.only\");\r\n        this.hasAnOnlyDescribe = true;\r\n        this.pushToCurrentTestQueue(\"describe\", title, execBlock, true);\r\n    };\r\n\r\n    readonly it: ItWithSubMethods = ((title: string, execBlock: (done?: (result?: Error | any) => void) => Promise<Error | any> | any, options?: Partial<ItOptions>): void => {\r\n        this.throwIfTestInProgress(\"it\");\r\n        this.pushToCurrentTestQueue(\"it\", title, execBlock, false, options ? options.timeoutMs : undefined);\r\n    }) as ItWithSubMethods;\r\n\r\n    private itOnly = (title: string, execBlock: (done?: (result?: Error | any) => void) => Promise<Error | any> | any, options?: Partial<ItOptions>): void => {\r\n        this.throwIfTestInProgress(\"it.only\");\r\n        this.hasAnOnlyIt = true;\r\n        this.pushToCurrentTestQueue(\"it\", title, execBlock, true, options ? options.timeoutMs : undefined);\r\n    };\r\n\r\n    before(execBlock: (done?: (result?: Error | any) => void) => Promise<Error | any> | any) {\r\n        this.throwIfTestInProgress(\"before\");\r\n        const beforeQueueStack = this.queueStacks[\"before\"];\r\n        beforeQueueStack[0].push(execBlock);\r\n    }\r\n\r\n    beforeEach(execBlock: (done?: (result?: Error | any) => void) => Promise<Error | any> | any) {\r\n        this.throwIfTestInProgress(\"beforeEach\");\r\n        const beforeEachQueueStack = this.queueStacks[\"beforeEach\"];\r\n        beforeEachQueueStack[0].push(execBlock);\r\n    }\r\n\r\n    after(execBlock: (done?: (result?: Error | any) => void) => Promise<Error | any> | any) {\r\n        this.throwIfTestInProgress(\"after\");\r\n        const afterQueueStack = this.queueStacks[\"after\"];\r\n        afterQueueStack[0].push(execBlock);\r\n    }\r\n\r\n    afterEach(execBlock: (done?: (result?: Error | any) => void) => Promise<Error | any> | any) {\r\n        this.throwIfTestInProgress(\"afterEach\");\r\n        const afterEachQueueStack = this.queueStacks[\"afterEach\"];\r\n        afterEachQueueStack[0].push(execBlock);\r\n    }\r\n\r\n    /**\r\n     * Triggers a test run based on the describes and its added previously.\r\n     *\r\n     * If a test is already in progress, an error will be returned.\r\n     */\r\n    run(): Promise<RunResults> {\r\n        if (this.currentRun) {\r\n            throw new Error(\"Can't start a test run if one is already in progress!\");\r\n        }\r\n\r\n        this.currentRun = this.runNextTestQueue().then(() => {\r\n            const results = this.runResults;\r\n            this.currentRun = null;\r\n\r\n            this.resetRunResults();\r\n            return results;\r\n        }).catch((e) => {\r\n            this.currentRun = null;\r\n\r\n            throw e;\r\n        });\r\n\r\n        return this.currentRun;\r\n    }\r\n\r\n    /**\r\n     * If a test is in progress, the current information for the test will be returned.\r\n     *\r\n     * If not, an error will be thrown.\r\n     */\r\n    getCurrentTestInfo(): TestInfo {\r\n        if (!this.currentTest) {\r\n            throw new Error(\"Can't obtain TestInfo if not actively in a test!\");\r\n        }\r\n\r\n        return this.currentTest;\r\n    }\r\n\r\n    /**\r\n     * Resets all pending state, including all attached before, beforeEach, after, afterEach, tests, describes, etc.\r\n     *\r\n     * If a test run is already in progress, an error will be thrown.\r\n     */\r\n    reset(): void {\r\n        if (this.currentRun) {\r\n            throw new Error(\"Can't reset if a test run is already in progress!\");\r\n        }\r\n\r\n        this.resetRunResults();\r\n        this.testRunCancelled = false;\r\n        this.hasAnOnlyIt = false;\r\n        this.hasAnOnlyDescribe = false;\r\n        this.testQueueStack = [];\r\n        for (const type of QueueStackTypes) {\r\n            this.queueStacks[type] = [[]];\r\n        }\r\n    }\r\n\r\n    cancel(): Promise<RunResults> {\r\n        if (!this.currentRun) {\r\n            return Promise.reject(new Error(\"Not currently executing a test run! Unable to cancel accordingly.\"));\r\n        }\r\n\r\n        this.testRunCancelled = true;\r\n        return this.currentRun.then((results) => {\r\n            this.reset();\r\n            return results;\r\n        });\r\n    }\r\n\r\n    private pushToCurrentTestQueue(type: \"it\" | \"describe\", title: string, execBlock: () => void, only?: boolean, timeoutMs?: number) {\r\n        if (this.testQueueStack.length === 0) {\r\n            const testQueue: TestQueue = {\r\n                titleChain: [],\r\n                tests: [],\r\n                evaluatedBefores: false\r\n            };\r\n            this.testQueueStack.push(testQueue);\r\n        }\r\n\r\n        const currentEntry = this.testQueueStack[this.testQueueStack.length - 1];\r\n        const testEntry: TestEntry = {\r\n            title: title,\r\n            type: type,\r\n            callback: execBlock,\r\n            absoluteFilePath: this.lastFilePathSet\r\n        };\r\n\r\n        if (only) {\r\n            testEntry.only = only;\r\n        }\r\n\r\n        if (timeoutMs > 0) {\r\n            testEntry.timeoutMs = timeoutMs;\r\n        }\r\n\r\n        currentEntry.tests.push(testEntry);\r\n    }\r\n\r\n    private runNextTestQueue = (): Promise<void> => {\r\n        if (this.testQueueStack.length === 0) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const queue = this.testQueueStack.shift();\r\n        let evaluatedTest = false;\r\n\r\n        let promise = Promise.resolve();\r\n        for (let i = 0; i < queue.tests.length; i++) {\r\n            const entry = queue.tests[i];\r\n            if (entry.absoluteFilePath !== this.currentlyExecutingFilePath) {\r\n                this.currentlyExecutingFilePath = entry.absoluteFilePath;\r\n                this.eventEmitter.emit(\"activeFileChanged\", this.currentlyExecutingFilePath);\r\n            }\r\n\r\n            promise = promise.then(() => {\r\n                if (this.testRunCancelled) {\r\n                    return Promise.resolve();\r\n                }\r\n                if (entry.type === \"describe\") {\r\n                    return this.evaluateDescribe(queue, entry);\r\n                } else {\r\n                    return this.evaluateTest(queue, entry)\r\n                        .then((evaluatedATest: boolean) => {\r\n                            evaluatedTest = evaluatedATest;\r\n                        });\r\n                }\r\n            });\r\n        }\r\n\r\n        return promise.then(() => {\r\n            if (evaluatedTest) {\r\n                return this.evaluateQueueWithTimeout(\"after\")\r\n            } else {\r\n                return Promise.resolve();\r\n            }\r\n        });\r\n    };\r\n\r\n    private evaluateDescribe(queue: TestQueue, entry: TestEntry): Promise<void> {\r\n        if (this.hasAnOnlyDescribe && !entry.only) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        this.testQueueStack.push({\r\n            titleChain: [].concat(queue.titleChain, entry.title),\r\n            tests: [],\r\n            evaluatedBefores: false\r\n        });\r\n\r\n        for (const type of QueueStackTypes) {\r\n            this.queueStacks[type].push([]);\r\n        }\r\n\r\n        this.eventEmitter.emit(\"beforeDescribe\", entry.title);\r\n\r\n        const startTime = Date.now();\r\n        return this.asyncPromisifier.exec(entry.callback)\r\n            .then(this.runNextTestQueue)\r\n            .then(() => {\r\n                for (const type of QueueStackTypes) {\r\n                    this.queueStacks[type].shift();\r\n                }\r\n\r\n                const describeDurationMs = Date.now() - startTime;\r\n                this.eventEmitter.emit(\"afterDescribe\", entry.title, describeDurationMs);\r\n            });\r\n    }\r\n\r\n    private evaluateTest(queue: TestQueue, entry: TestEntry): Promise<boolean> {\r\n        if (this.hasAnOnlyIt && !entry.only) {\r\n            return Promise.resolve(false);\r\n        }\r\n\r\n        let promise = Promise.resolve();\r\n        if (!queue.evaluatedBefores) {\r\n            queue.evaluatedBefores = true;\r\n            promise = promise.then(() => this.evaluateQueueWithTimeout(\"before\"));\r\n        }\r\n\r\n        return promise.then(() => this.evaluateQueueWithTimeout(\"beforeEach\")\r\n            .then(() => {\r\n                    this.eventEmitter.emit(\"beforeTest\", entry.title);\r\n                    const startTime = Date.now();\r\n                    this.currentTest = entry;\r\n\r\n                    Object.defineProperty(entry.callback, \"name\", { value: \"Test: \" + entry.title, writable: false });\r\n                    const timeoutValue = entry.timeoutMs >= 0 ? entry.timeoutMs : this.getTimeoutValue(\"it\");\r\n                    return this.timeoutPromisifier.wrap(this.asyncPromisifier.exec(entry.callback), timeoutValue)\r\n                        .then(() => this.eventEmitter.emitAndWaitForCompletion(\"beforeTestSuccess\", entry.title))\r\n                        .then(() => {\r\n                            this.runResults.totalSuccesses++;\r\n\r\n                            const testDurationMs = Date.now() - startTime;\r\n                            this.eventEmitter.emit(\"testSuccess\", entry.title, testDurationMs);\r\n                        })\r\n                        .catch((error: Error) => {\r\n                            if (error instanceof TimeoutError) {\r\n                                this.runResults.totalTimeouts++;\r\n                                this.runResults.timeoutInfo.push({\r\n                                    describeChain: queue.titleChain,\r\n                                    title: entry.title,\r\n                                    elapsedMs: error.elapsedMs,\r\n                                    timeoutMs: error.timeoutMs\r\n                                });\r\n                                this.eventEmitter.emit(\"testTimeout\", entry.title, error.elapsedMs, error.timeoutMs);\r\n                            } else {\r\n                                this.runResults.totalFailures++;\r\n                                this.runResults.failureInfo.push({\r\n                                    describeChain: queue.titleChain,\r\n                                    title: entry.title,\r\n                                    error: error\r\n                                });\r\n                                this.eventEmitter.emit(\"testFail\", entry.title, error, Date.now() - startTime);\r\n                            }\r\n\r\n                            // If we want to stop additional execution on the first fail, just cancel the rest of the run.\r\n                            if (this.config.stopOnFirstFail) {\r\n                                this.testRunCancelled = true;\r\n                            }\r\n                        })\r\n                        .then(() => this.evaluateQueueWithTimeout(\"afterEach\"))\r\n                        .then(() => {\r\n                            this.runResults.totalTests++;\r\n                            this.currentTest = null;\r\n                        })\r\n                        .catch((e) => {\r\n                            this.runResults.totalTests++;\r\n                            this.currentTest = null;\r\n\r\n                            throw e;\r\n                        });\r\n                }\r\n            )).then(() => true);\r\n    }\r\n\r\n    private evaluateQueueWithTimeout(type: QueueStackType): Promise<void> {\r\n        return this.timeoutPromisifier.wrap(this.evaluateQueue(type), this.getTimeoutValue(type));\r\n    }\r\n\r\n    private evaluateQueue(type: QueueStackType): Promise<void> {\r\n        const queueStack = this.queueStacks[type];\r\n        let promise = Promise.resolve();\r\n\r\n        if (type === \"before\" || type === \"beforeEach\") {\r\n            // Befores operate outside-in, first-last.\r\n            for (let i = 0; i < queueStack.length; i++) {\r\n                const queue = queueStack[i];\r\n                for (let j = 0; j < queue.length; j++) {\r\n                    promise = promise.then(() => this.asyncPromisifier.exec(queue[j]));\r\n                }\r\n            }\r\n        } else {\r\n            // Afters operate inside-out, last-first\r\n            for (let i = queueStack.length - 1; i >= 0; i--) {\r\n                const queue = queueStack[i];\r\n                for (let j = queue.length - 1; j >= 0; j--) {\r\n                    promise = promise.then(() => this.asyncPromisifier.exec(queue[j]));\r\n                }\r\n            }\r\n        }\r\n\r\n        return promise;\r\n    }\r\n\r\n    private getTimeoutValue<T extends keyof TimeoutConfig>(type: T): number {\r\n        if (typeof this.config.timeoutMs === \"number\") {\r\n            return this.config.timeoutMs;\r\n        } else {\r\n            return this.config.timeoutMs[type];\r\n        }\r\n    }\r\n\r\n    private throwIfTestInProgress = (name: string): void => {\r\n        if (this.currentTest) {\r\n            throw new Error(`Cannot add an ${name} block while executing a test!`);\r\n        }\r\n    };\r\n\r\n    private resetRunResults = () => {\r\n        this.runResults = {\r\n            elapsedTimeMs: 0,\r\n            totalTests: 0,\r\n            totalSuccesses: 0,\r\n            totalFailures: 0,\r\n            totalTimeouts: 0,\r\n            failureInfo: [],\r\n            timeoutInfo: []\r\n        };\r\n    }\r\n}\r\n\r\nexport {TestRunner};\r\n","/**\n * Async-method-specific timeout config. These timeout values are applied to each named method accordingly.\n */\ninterface TimeoutConfig {\n    it?: number;\n    before?: number;\n    beforeEach?: number;\n    after?: number;\n    afterEach?: number;\n}\n\n/**\n * Configuration to be set by the user for an instance of an Umbra Test Runner.\n */\ninterface TestRunnerConfig {\n\n    /**\n     * The amount of time to wait until cancelling a long-running test. If a single value is given, this timeout is\n     * applied to all asynchronous execution (it, before, beforeEach, after, afterEach).\n     *\n     * Alternatively, an object may be used to set these individually.\n     */\n    timeoutMs?: number | TimeoutConfig;\n\n    /**\n     * Whether test execution should stop on the first seen failure. Defaults to false.\n     */\n    stopOnFirstFail?: boolean;\n}\n\n/**\n * A helper method to merge multiple sources of configuration.\n *\n * @param to - The base configuration object to be merged into.\n * @param from - The configuration object to merge from.\n */\nfunction mergeConfig(to: TestRunnerConfig, from?: Partial<TestRunnerConfig>): TestRunnerConfig {\n    if (!from || typeof from !== \"object\") {\n        return to;\n    }\n\n    if (typeof to.timeoutMs === \"object\" && typeof from.timeoutMs === \"object\") {\n        for (const entryType of [\"it\", \"before\", \"beforeEach\", \"after\", \"afterEach\"]) {\n            if (typeof from.timeoutMs[entryType] === \"number\") {\n                to.timeoutMs[entryType] = from.timeoutMs[entryType];\n            }\n        }\n    } else if (typeof from.timeoutMs !== \"undefined\") {\n        to.timeoutMs = from.timeoutMs;\n    }\n\n    if (to.stopOnFirstFail !== from.stopOnFirstFail) {\n        to.stopOnFirstFail = from.stopOnFirstFail;\n    }\n\n    return to;\n}\n\nexport {TimeoutConfig, TestRunnerConfig, mergeConfig};\n"],"names":["AsyncPromisifier","[object Object]","fn","length","Promise","resolve","reject","result","Error","e","TimeoutError","message","elapsedMs","timeoutMs","super","this","TimeoutPromisifier","promise","startTime","Date","now","timerId","timeoutPromise","setTimeout","catch","clearTimeout","race","then","DefaultTestRunnerConfig","stopOnFirstFail","union","arrayA","arrayB","item","indexOf","push","without","array","indexOfItem","splice","SimpleEventEmitter","event","callback","onListeners","onceListeners","args","call","promises","all","results","QueueStackTypes","config","eventEmitter","before","beforeEach","after","afterEach","title","execBlock","throwIfTestInProgress","pushToCurrentTestQueue","hasAnOnlyDescribe","options","undefined","hasAnOnlyIt","testQueueStack","queue","shift","evaluatedTest","i","tests","entry","absoluteFilePath","currentlyExecutingFilePath","emit","testRunCancelled","type","evaluateDescribe","evaluateTest","evaluatedATest","evaluateQueueWithTimeout","name","currentTest","runResults","elapsedTimeMs","totalTests","totalSuccesses","totalFailures","totalTimeouts","failureInfo","timeoutInfo","to","from","entryType","mergeConfig","it","only","itOnly","describe","describeOnly","resetRunResults","absolutePath","lastFilePathSet","on","once","off","queueStacks","currentRun","runNextTestQueue","reset","testQueue","titleChain","evaluatedBefores","currentEntry","testEntry","concat","asyncPromisifier","exec","describeDurationMs","Object","defineProperty","value","writable","timeoutValue","getTimeoutValue","timeoutPromisifier","wrap","emitAndWaitForCompletion","testDurationMs","error","describeChain","evaluateQueue","queueStack","j"],"mappings":"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"}