class e{exec(e){if(1===e.length)return new Promise((t,s)=>{e(e=>{e instanceof Error?s(e):t(e)})});try{return Promise.resolve(e())}catch(e){return Promise.reject(e)}}}class t extends Error{constructor(e,t,s){super(e),this.timeoutMs=s}}class s{wrap(e,s){if(s<=0)return e;const i=Date.now();let r=null;const n=new Promise((e,n)=>{r=setTimeout(()=>{const e=Date.now()-i;n(new t(`Async task timeout exceeded! Elapsed: ${e}, timeout: ${s}ms.`,e,s))})});return Promise.race([e,n]).then(e=>(clearTimeout(r),e))}}const i={timeoutMs:100,stopOnFirstFail:!1};function r(e,t){if(!e)return t||[];if(!t)return e;for(const s of t)-1===e.indexOf(s)&&e.push(s);return e}function n(e,t){if(!e)return[];const s=e.indexOf(t);return-1!==s&&e.splice(s,1),e}class o{constructor(){this.onListeners={},this.onceListeners={}}on(e,t){this.onListeners[e]=r(this.onListeners[e],[t])}once(e,t){this.onceListeners[e]=r(this.onceListeners[e],[t])}off(e,t){this.onListeners[e]=n(this.onListeners[e],t),this.onceListeners[e]=n(this.onceListeners[e],t)}emit(e,...t){if(this.onListeners[e])for(const s of this.onListeners[e])s.call(null,...t);if(this.onceListeners[e]&&this.onceListeners[e].length>0){for(const s of this.onceListeners[e])s.call(null,...t);this.onceListeners[e]=[]}}emitAndWaitForCompletion(e,...t){const s=[];if(this.onListeners[e])for(const i of this.onListeners[e])try{s.push(Promise.resolve(i.call(null,...t)))}catch(e){s.push(Promise.reject(e))}if(this.onceListeners[e]&&this.onceListeners[e].length>0){for(const i of this.onceListeners[e])try{s.push(Promise.resolve(i.call(null,...t)))}catch(e){s.push(Promise.reject(e))}this.onceListeners[e]=[]}return Promise.all(s).then(e=>{})}}const u=["before","beforeEach","after","afterEach"];class h{constructor(t,r=new o){this.asyncPromisifier=new e,this.timeoutPromisifier=new s,this.testQueueStack=[],this.queueStacks={before:[[]],beforeEach:[[]],after:[[]],afterEach:[[]]},this.hasAnOnlyDescribe=!1,this.hasAnOnlyIt=!1,this.currentTest=null,this.testRunCancelled=!1,this.describe=(e,t)=>{this.throwIfTestInProgress("describe"),this.pushToCurrentTestQueue("describe",e,t)},this.describeOnly=(e,t)=>{this.throwIfTestInProgress("describe.only"),this.hasAnOnlyDescribe=!0,this.pushToCurrentTestQueue("describe",e,t,!0)},this.it=(e,t,s)=>{this.throwIfTestInProgress("it"),this.pushToCurrentTestQueue("it",e,t,!1,s?s.timeoutMs:void 0)},this.itOnly=(e,t,s)=>{this.throwIfTestInProgress("it.only"),this.hasAnOnlyIt=!0,this.pushToCurrentTestQueue("it",e,t,!0,s?s.timeoutMs:void 0)},this.runNextTestQueue=()=>{if(0===this.testQueueStack.length)return Promise.resolve();const e=this.testQueueStack.shift();let t=!1,s=Promise.resolve();for(let i=0;i<e.tests.length;i++){const r=e.tests[i];s=s.then(()=>{if(!this.testRunCancelled)return"describe"===r.type?this.evaluateDescribe(e,r):this.evaluateTest(e,r).then(e=>{t=e})})}return s.then(()=>{if(t)return this.evaluateQueueWithTimeout("after")})},this.throwIfTestInProgress=e=>{if(this.currentTest)throw new Error(`Cannot add an ${e} block while executing a test!`)},this.resetRunResults=()=>{this.runResults={elapsedTimeMs:0,totalTests:0,totalSuccesses:0,totalFailures:0,totalTimeouts:0,failureInfo:[],timeoutInfo:[]}},this.config=function(e,t){if(!t||"object"!=typeof t)return e;if("object"==typeof e.timeoutMs&&"object"==typeof t.timeoutMs)for(const s of["it","before","beforeEach","after","afterEach"])"number"==typeof t.timeoutMs[s]&&(e.timeoutMs[s]=t.timeoutMs[s]);else void 0!==t.timeoutMs&&(e.timeoutMs=t.timeoutMs);return e.stopOnFirstFail!==t.stopOnFirstFail&&(e.stopOnFirstFail=t.stopOnFirstFail),e}(i,t),this.eventEmitter=r,this.it.only=this.itOnly,this.describe.only=this.describeOnly,this.resetRunResults()}on(e,t){this.eventEmitter.on(e,t)}once(e,t){this.eventEmitter.once(e,t)}off(e,t){this.eventEmitter.off(e,t)}before(e){this.throwIfTestInProgress("before"),this.queueStacks.before[0].push(e)}beforeEach(e){this.throwIfTestInProgress("beforeEach"),this.queueStacks.beforeEach[0].push(e)}after(e){this.throwIfTestInProgress("after"),this.queueStacks.after[0].push(e)}afterEach(e){this.throwIfTestInProgress("afterEach"),this.queueStacks.afterEach[0].push(e)}run(){if(this.currentRun)throw new Error("Can't start a test run if one is already in progress!");return this.currentRun=this.runNextTestQueue().then(()=>{const e=this.runResults;return this.resetRunResults(),e}).finally(()=>{this.currentRun=null}),this.currentRun}getCurrentTestInfo(){if(!this.currentTest)throw new Error("Can't obtain TestInfo if not actively in a test!");return this.currentTest}reset(){if(this.currentRun)throw new Error("Can't reset if a test run is already in progress!");this.resetRunResults(),this.testRunCancelled=!1,this.hasAnOnlyIt=!1,this.hasAnOnlyDescribe=!1,this.testQueueStack=[];for(const e of u)this.queueStacks[e]=[[]]}cancel(){if(this.currentRun)return this.testRunCancelled=!0,this.currentRun.then(e=>(this.reset(),e))}pushToCurrentTestQueue(e,t,s,i,r){if(0===this.testQueueStack.length){const e={titleChain:[],tests:[],evaluatedBefores:!1};this.testQueueStack.push(e)}const n=this.testQueueStack[this.testQueueStack.length-1],o={title:t,type:e,callback:s};i&&(o.only=i),r>0&&(o.timeoutMs=r),n.tests.push(o)}evaluateDescribe(e,t){if(this.hasAnOnlyDescribe&&!t.only)return Promise.resolve();this.testQueueStack.push({titleChain:[].concat(e.titleChain,t.title),tests:[],evaluatedBefores:!1});for(const e of u)this.queueStacks[e].push([]);this.eventEmitter.emit("beforeDescribe",t.title);const s=Date.now();return this.asyncPromisifier.exec(t.callback).then(this.runNextTestQueue).then(()=>{for(const e of u)this.queueStacks[e].shift();const e=Date.now()-s;this.eventEmitter.emit("afterDescribe",t.title,e)})}evaluateTest(e,s){if(this.hasAnOnlyIt&&!s.only)return Promise.resolve(!1);let i=Promise.resolve();return e.evaluatedBefores||(e.evaluatedBefores=!0,i=i.then(()=>this.evaluateQueueWithTimeout("before"))),i.then(()=>this.evaluateQueueWithTimeout("beforeEach").then(()=>{this.eventEmitter.emit("beforeTest",s.title);const i=Date.now();return this.currentTest=s,this.timeoutPromisifier.wrap(this.asyncPromisifier.exec(s.callback),this.getTimeoutValue("it")).then(()=>this.eventEmitter.emitAndWaitForCompletion("beforeTestSuccess",s.title)).then(()=>{this.runResults.totalSuccesses++;const e=Date.now()-i;this.eventEmitter.emit("testSuccess",s.title,e)}).catch(r=>{r instanceof t?(this.runResults.totalTimeouts++,this.runResults.timeoutInfo.push({describeChain:e.titleChain,title:s.title,elapsedMs:r.elapsedMs,timeoutMs:r.timeoutMs}),this.eventEmitter.emit("testTimeout",s.title,r.elapsedMs,r.timeoutMs)):(this.runResults.totalFailures++,this.runResults.failureInfo.push({describeChain:e.titleChain,title:s.title,error:r}),this.eventEmitter.emit("testFail",s.title,r,Date.now()-i)),this.config.stopOnFirstFail&&(this.testRunCancelled=!0)}).then(()=>this.evaluateQueueWithTimeout("afterEach")).finally(()=>{this.runResults.totalTests++,this.currentTest=null})})).then(()=>!0)}evaluateQueueWithTimeout(e){return this.timeoutPromisifier.wrap(this.evaluateQueue(e),this.getTimeoutValue(e))}evaluateQueue(e){const t=this.queueStacks[e];let s=Promise.resolve();if("before"===e||"beforeEach"===e)for(let e=0;e<t.length;e++){const i=t[e];for(let e=0;e<i.length;e++)s=s.then(()=>this.asyncPromisifier.exec(i[e]))}else for(let e=t.length-1;e>=0;e--){const i=t[e];for(let e=i.length-1;e>=0;e--)s=s.then(()=>this.asyncPromisifier.exec(i[e]))}return s}getTimeoutValue(e){return"number"==typeof this.config.timeoutMs?this.config.timeoutMs:this.config.timeoutMs[e]}}export{h as TestRunner};
