class t{exec(t,e){if(Object.defineProperty(t,"name",{value:e,writable:!1}),1===t.length)return new Promise((e,s)=>{t(t=>{t instanceof Error?s(t):e(t)})});try{return Promise.resolve(t())}catch(t){return Promise.reject(t)}}}class e extends Error{constructor(t,e,s){super(t),this.timeoutMs=s}}class s{wrap(t,s){if(s<=0)return t;const i=Date.now();let r=null;const n=new Promise((t,n)=>{r=setTimeout(()=>{const t=Date.now()-i;n(new e(`Async task timeout exceeded! Elapsed: ${t}, timeout: ${s}ms.`,t,s))},s)});return t.catch(()=>{clearTimeout(r)}),Promise.race([t,n]).then(t=>(clearTimeout(r),t))}}const i={timeoutMs:100,stopOnFirstFail:!1};function r(t,e){if(!t)return e||[];if(!e)return t;for(const s of e)-1===t.indexOf(s)&&t.push(s);return t}function n(t,e){if(!t)return[];const s=t.indexOf(e);return-1!==s&&t.splice(s,1),t}class o{constructor(){this.onListeners={},this.onceListeners={}}on(t,e){this.onListeners[t]=r(this.onListeners[t],[e])}once(t,e){this.onceListeners[t]=r(this.onceListeners[t],[e])}off(t,e){this.onListeners[t]=n(this.onListeners[t],e),this.onceListeners[t]=n(this.onceListeners[t],e)}emit(t,...e){if(this.onListeners[t])for(const s of this.onListeners[t])s.call(null,...e);if(this.onceListeners[t]&&this.onceListeners[t].length>0){for(const s of this.onceListeners[t])s.call(null,...e);this.onceListeners[t]=[]}}emitAndWaitForCompletion(t,...e){const s=[];if(this.onListeners[t])for(const i of this.onListeners[t])try{s.push(Promise.resolve(i.call(null,...e)))}catch(t){s.push(Promise.reject(t))}if(this.onceListeners[t]&&this.onceListeners[t].length>0){for(const i of this.onceListeners[t])try{s.push(Promise.resolve(i.call(null,...e)))}catch(t){s.push(Promise.reject(t))}this.onceListeners[t]=[]}return Promise.all(s).then(t=>{})}}var u=function(t,e,s,i){return new(s||(s=Promise))((function(r,n){function o(t){try{h(i.next(t))}catch(t){n(t)}}function u(t){try{h(i.throw(t))}catch(t){n(t)}}function h(t){t.done?r(t.value):new s((function(e){e(t.value)})).then(o,u)}h((i=i.apply(t,e||[])).next())}))};const h=["before","beforeEach","after","afterEach"];class c{constructor(e,r=new o){this.asyncPromisifier=new t,this.timeoutPromisifier=new s,this.testQueueStack=[],this.queueStacks={before:[],beforeEach:[],after:[],afterEach:[]},this.currentTest=null,this.testRunCancelled=!1,this.describe=(t,e)=>{this.throwIfTestInProgress("describe"),this.pushToCurrentTestQueue("describe",t,e)},this.describeOnly=(t,e)=>{this.throwIfTestInProgress("describe.only"),this.pushToCurrentTestQueue("describe",t,e,!0)},this.it=(t,e,s)=>{this.throwIfTestInProgress("it"),this.pushToCurrentTestQueue("it",t,e,!1,s?s.timeoutMs:void 0)},this.itOnly=(t,e,s)=>{this.throwIfTestInProgress("it.only"),this.pushToCurrentTestQueue("it",t,e,!0,s?s.timeoutMs:void 0)},this.runNextTestQueue=()=>u(this,void 0,void 0,(function*(){if(0===this.testQueueStack.length)return;let t=!1;const e=this.testQueueStack.shift();if(null!==e.firstOnlyIndex)t=yield this.executeTest(e,e.tests[e.firstOnlyIndex]);else for(let s=0;s<e.tests.length;s++)t=(yield this.executeTest(e,e.tests[s]))||t;t&&(yield this.evaluateQueueWithTimeout("after"))})),this.throwIfTestInProgress=t=>{if(this.currentTest)throw new Error(`Cannot add an ${t} block while executing a test!`)},this.resetRunResults=()=>{this.runResults={elapsedTimeMs:0,totalTests:0,totalSuccesses:0,totalFailures:0,totalTimeouts:0,failureInfo:[],timeoutInfo:[]}},this.config=function(t,e){if(!e||"object"!=typeof e)return t;if("object"==typeof t.timeoutMs&&"object"==typeof e.timeoutMs)for(const s of["it","before","beforeEach","after","afterEach"])"number"==typeof e.timeoutMs[s]&&(t.timeoutMs[s]=e.timeoutMs[s]);else void 0!==e.timeoutMs&&(t.timeoutMs=e.timeoutMs);return t.stopOnFirstFail!==e.stopOnFirstFail&&(t.stopOnFirstFail=e.stopOnFirstFail),t}(i,e),this.eventEmitter=r,this.it.only=this.itOnly,this.describe.only=this.describeOnly,this.resetRunResults()}setCurrentFile(t){this.lastFilePathSet=t}on(t,e){this.eventEmitter.on(t,e)}once(t,e){this.eventEmitter.once(t,e)}off(t,e){this.eventEmitter.off(t,e)}before(t){this.throwIfTestInProgress("before");const e=this.queueStacks.before;0===e.length?e.push([t]):e[0].push(t)}beforeEach(t){this.throwIfTestInProgress("beforeEach");const e=this.queueStacks.beforeEach;0===e.length?e.push([t]):e[0].push(t)}after(t){this.throwIfTestInProgress("after");const e=this.queueStacks.after;0===e.length?e.push([t]):e[0].push(t)}afterEach(t){this.throwIfTestInProgress("afterEach");const e=this.queueStacks.afterEach;0===e.length?e.push([t]):e[0].push(t)}run(){if(this.currentRun)throw new Error("Can't start a test run if one is already in progress!");const t=Date.now();return this.currentRun=this.runNextTestQueue().then(()=>{const e=this.runResults;return e.elapsedTimeMs=Date.now()-t,this.currentRun=null,this.resetRunResults(),e}).catch(t=>{throw this.currentRun=null,t}),this.currentRun}getCurrentTestInfo(){if(!this.currentTest)throw new Error("Can't obtain TestInfo if not actively in a test!");return this.currentTest}reset(){if(this.currentRun)throw new Error("Can't reset if a test run is already in progress!");this.resetRunResults(),this.testRunCancelled=!1,this.testQueueStack=[];for(const t of h)this.queueStacks[t]=[[]]}cancel(){return this.currentRun?(this.testRunCancelled=!0,this.currentRun.then(t=>(this.reset(),t))):Promise.reject(new Error("Not currently executing a test run! Unable to cancel accordingly."))}pushToCurrentTestQueue(t,e,s,i,r){if(0===this.testQueueStack.length){const t={titleChain:[],tests:[],evaluatedBefores:!1,firstOnlyIndex:i?0:null};this.testQueueStack.push(t)}const n=this.testQueueStack[this.testQueueStack.length-1],o={title:e,type:t,callback:s,absoluteFilePath:this.lastFilePathSet};i&&null===n.firstOnlyIndex&&(n.firstOnlyIndex=n.tests.length),r>0&&(o.timeoutMs=r),n.tests.push(o)}executeTest(t,e){return u(this,void 0,void 0,(function*(){return e.absoluteFilePath!==this.currentlyExecutingFilePath&&(this.currentlyExecutingFilePath=e.absoluteFilePath,this.eventEmitter.emit("activeFileChanged",this.currentlyExecutingFilePath)),!this.testRunCancelled&&("describe"===e.type?this.evaluateDescribe(t,e):this.evaluateTest(t,e))}))}evaluateDescribe(t,e){return u(this,void 0,void 0,(function*(){this.testQueueStack.push({titleChain:[].concat(t.titleChain,e.title),tests:[],evaluatedBefores:!1,firstOnlyIndex:null});for(const t of h)this.queueStacks[t].push([]);this.eventEmitter.emit("beforeDescribe",e.title);const s=Date.now();yield this.asyncPromisifier.exec(e.callback,"describe"),yield this.runNextTestQueue();for(const t of h)"before"===t||"beforeEach"===t?this.queueStacks[t].pop():this.queueStacks[t].shift();const i=Date.now()-s;return this.eventEmitter.emit("afterDescribe",e.title,i),!1}))}evaluateTest(t,e){return u(this,void 0,void 0,(function*(){t.evaluatedBefores||(t.evaluatedBefores=!0,yield this.evaluateQueueWithTimeout("before")),yield this.evaluateQueueWithTimeout("beforeEach"),this.eventEmitter.emit("beforeTest",e.title),this.currentTest=e;try{yield this.executeTestCallback(e,t.titleChain),yield this.evaluateQueueWithTimeout("afterEach")}finally{this.runResults.totalTests++,this.currentTest=null}return!0}))}executeTestCallback(t,s){return u(this,void 0,void 0,(function*(){const i=Date.now(),r=t.timeoutMs>=0?t.timeoutMs:this.getTimeoutValue("it");try{yield this.timeoutPromisifier.wrap(this.asyncPromisifier.exec(t.callback,"Test: "+t.title),r),yield this.eventEmitter.emitAndWaitForCompletion("beforeTestSuccess",t.title),this.runResults.totalSuccesses++;const e=Date.now()-i;this.eventEmitter.emit("testSuccess",t.title,e)}catch(r){r instanceof e?(this.runResults.totalTimeouts++,this.runResults.timeoutInfo.push({describeChain:s,title:t.title,elapsedMs:r.elapsedMs,timeoutMs:r.timeoutMs}),this.eventEmitter.emit("testTimeout",t.title,r.elapsedMs,r.timeoutMs)):(this.runResults.totalFailures++,this.runResults.failureInfo.push({describeChain:s,title:t.title,error:r}),this.eventEmitter.emit("testFail",t.title,r,Date.now()-i)),this.config.stopOnFirstFail&&(this.testRunCancelled=!0)}}))}evaluateQueueWithTimeout(t){return this.timeoutPromisifier.wrap(this.evaluateQueue(t),this.getTimeoutValue(t))}evaluateQueue(t){const e=this.queueStacks[t];let s=Promise.resolve();if("before"===t||"beforeEach"===t)for(let i=0;i<e.length;i++){const r=e[i];for(let e=0;e<r.length;e++)s=s.then(()=>this.asyncPromisifier.exec(r[e],t))}else for(let i=e.length-1;i>=0;i--){const r=e[i];for(let e=r.length-1;e>=0;e--)s=s.then(()=>this.asyncPromisifier.exec(r[e],t))}return s}getTimeoutValue(t){const e=this.config.timeoutMs;return"number"==typeof e?e:e[t]}}export{c as TestRunner};
