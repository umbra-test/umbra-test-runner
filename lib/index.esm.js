class t{exec(t){if(1===t.length)return new Promise((e,s)=>{t(t=>{t instanceof Error?s(t):e(t)})});try{return Promise.resolve(t())}catch(t){return Promise.reject(t)}}}class e extends Error{constructor(t,e,s){super(t),this.timeoutMs=s}}class s{wrap(t,s){if(s<=0)return t;const i=Date.now();let r=null;const n=new Promise((t,n)=>{r=setTimeout(()=>{const t=Date.now()-i;n(new e(`Async task timeout exceeded! Elapsed: ${t}, timeout: ${s}ms.`,t,s))},s)});return t.catch(()=>{clearTimeout(r)}),Promise.race([t,n]).then(t=>(clearTimeout(r),t))}}const i={timeoutMs:100,stopOnFirstFail:!1};function r(t,e){if(!t)return e||[];if(!e)return t;for(const s of e)-1===t.indexOf(s)&&t.push(s);return t}function n(t,e){if(!t)return[];const s=t.indexOf(e);return-1!==s&&t.splice(s,1),t}class o{constructor(){this.onListeners={},this.onceListeners={}}on(t,e){this.onListeners[t]=r(this.onListeners[t],[e])}once(t,e){this.onceListeners[t]=r(this.onceListeners[t],[e])}off(t,e){this.onListeners[t]=n(this.onListeners[t],e),this.onceListeners[t]=n(this.onceListeners[t],e)}emit(t,...e){if(this.onListeners[t])for(const s of this.onListeners[t])s.call(null,...e);if(this.onceListeners[t]&&this.onceListeners[t].length>0){for(const s of this.onceListeners[t])s.call(null,...e);this.onceListeners[t]=[]}}emitAndWaitForCompletion(t,...e){const s=[];if(this.onListeners[t])for(const i of this.onListeners[t])try{s.push(Promise.resolve(i.call(null,...e)))}catch(t){s.push(Promise.reject(t))}if(this.onceListeners[t]&&this.onceListeners[t].length>0){for(const i of this.onceListeners[t])try{s.push(Promise.resolve(i.call(null,...e)))}catch(t){s.push(Promise.reject(t))}this.onceListeners[t]=[]}return Promise.all(s).then(t=>{})}}const u=["before","beforeEach","after","afterEach"];class h{constructor(e,r=new o){this.asyncPromisifier=new t,this.timeoutPromisifier=new s,this.testQueueStack=[],this.queueStacks={before:[[]],beforeEach:[[]],after:[[]],afterEach:[[]]},this.hasAnOnlyDescribe=!1,this.hasAnOnlyIt=!1,this.currentTest=null,this.testRunCancelled=!1,this.describe=(t,e)=>{this.throwIfTestInProgress("describe"),this.pushToCurrentTestQueue("describe",t,e)},this.describeOnly=(t,e)=>{this.throwIfTestInProgress("describe.only"),this.hasAnOnlyDescribe=!0,this.pushToCurrentTestQueue("describe",t,e,!0)},this.it=(t,e,s)=>{this.throwIfTestInProgress("it"),this.pushToCurrentTestQueue("it",t,e,!1,s?s.timeoutMs:void 0)},this.itOnly=(t,e,s)=>{this.throwIfTestInProgress("it.only"),this.hasAnOnlyIt=!0,this.pushToCurrentTestQueue("it",t,e,!0,s?s.timeoutMs:void 0)},this.runNextTestQueue=()=>{if(0===this.testQueueStack.length)return Promise.resolve();const t=this.testQueueStack.shift();let e=!1,s=Promise.resolve();for(let i=0;i<t.tests.length;i++){const r=t.tests[i];r.absoluteFilePath!==this.currentlyExecutingFilePath&&(this.currentlyExecutingFilePath=r.absoluteFilePath,this.eventEmitter.emit("activeFileChanged",this.currentlyExecutingFilePath)),s=s.then(()=>this.testRunCancelled?Promise.resolve():"describe"===r.type?this.evaluateDescribe(t,r):this.evaluateTest(t,r).then(t=>{e=t}))}return s.then(()=>e?this.evaluateQueueWithTimeout("after"):Promise.resolve())},this.throwIfTestInProgress=t=>{if(this.currentTest)throw new Error(`Cannot add an ${t} block while executing a test!`)},this.resetRunResults=()=>{this.runResults={elapsedTimeMs:0,totalTests:0,totalSuccesses:0,totalFailures:0,totalTimeouts:0,failureInfo:[],timeoutInfo:[]}},this.config=function(t,e){if(!e||"object"!=typeof e)return t;if("object"==typeof t.timeoutMs&&"object"==typeof e.timeoutMs)for(const s of["it","before","beforeEach","after","afterEach"])"number"==typeof e.timeoutMs[s]&&(t.timeoutMs[s]=e.timeoutMs[s]);else void 0!==e.timeoutMs&&(t.timeoutMs=e.timeoutMs);return t.stopOnFirstFail!==e.stopOnFirstFail&&(t.stopOnFirstFail=e.stopOnFirstFail),t}(i,e),this.eventEmitter=r,this.it.only=this.itOnly,this.describe.only=this.describeOnly,this.resetRunResults()}setCurrentFile(t){this.lastFilePathSet=t}on(t,e){this.eventEmitter.on(t,e)}once(t,e){this.eventEmitter.once(t,e)}off(t,e){this.eventEmitter.off(t,e)}before(t){this.throwIfTestInProgress("before"),this.queueStacks.before[0].push(t)}beforeEach(t){this.throwIfTestInProgress("beforeEach"),this.queueStacks.beforeEach[0].push(t)}after(t){this.throwIfTestInProgress("after"),this.queueStacks.after[0].push(t)}afterEach(t){this.throwIfTestInProgress("afterEach"),this.queueStacks.afterEach[0].push(t)}run(){if(this.currentRun)throw new Error("Can't start a test run if one is already in progress!");return this.currentRun=this.runNextTestQueue().then(()=>{const t=this.runResults;return this.currentRun=null,this.resetRunResults(),t}).catch(t=>{throw this.currentRun=null,t}),this.currentRun}getCurrentTestInfo(){if(!this.currentTest)throw new Error("Can't obtain TestInfo if not actively in a test!");return this.currentTest}reset(){if(this.currentRun)throw new Error("Can't reset if a test run is already in progress!");this.resetRunResults(),this.testRunCancelled=!1,this.hasAnOnlyIt=!1,this.hasAnOnlyDescribe=!1,this.testQueueStack=[];for(const t of u)this.queueStacks[t]=[[]]}cancel(){return this.currentRun?(this.testRunCancelled=!0,this.currentRun.then(t=>(this.reset(),t))):Promise.reject(new Error("Not currently executing a test run! Unable to cancel accordingly."))}pushToCurrentTestQueue(t,e,s,i,r){if(0===this.testQueueStack.length){const t={titleChain:[],tests:[],evaluatedBefores:!1};this.testQueueStack.push(t)}const n=this.testQueueStack[this.testQueueStack.length-1],o={title:e,type:t,callback:s,absoluteFilePath:this.lastFilePathSet};i&&(o.only=i),r>0&&(o.timeoutMs=r),n.tests.push(o)}evaluateDescribe(t,e){if(this.hasAnOnlyDescribe&&!e.only)return Promise.resolve();this.testQueueStack.push({titleChain:[].concat(t.titleChain,e.title),tests:[],evaluatedBefores:!1});for(const t of u)this.queueStacks[t].push([]);this.eventEmitter.emit("beforeDescribe",e.title);const s=Date.now();return this.asyncPromisifier.exec(e.callback).then(this.runNextTestQueue).then(()=>{for(const t of u)this.queueStacks[t].shift();const t=Date.now()-s;this.eventEmitter.emit("afterDescribe",e.title,t)})}evaluateTest(t,s){if(this.hasAnOnlyIt&&!s.only)return Promise.resolve(!1);let i=Promise.resolve();return t.evaluatedBefores||(t.evaluatedBefores=!0,i=i.then(()=>this.evaluateQueueWithTimeout("before"))),i.then(()=>this.evaluateQueueWithTimeout("beforeEach").then(()=>{this.eventEmitter.emit("beforeTest",s.title);const i=Date.now();this.currentTest=s;const r=s.timeoutMs>=0?s.timeoutMs:this.getTimeoutValue("it");return this.timeoutPromisifier.wrap(this.asyncPromisifier.exec(s.callback),r).then(()=>this.eventEmitter.emitAndWaitForCompletion("beforeTestSuccess",s.title)).then(()=>{this.runResults.totalSuccesses++;const t=Date.now()-i;this.eventEmitter.emit("testSuccess",s.title,t)}).catch(r=>{r instanceof e?(this.runResults.totalTimeouts++,this.runResults.timeoutInfo.push({describeChain:t.titleChain,title:s.title,elapsedMs:r.elapsedMs,timeoutMs:r.timeoutMs}),this.eventEmitter.emit("testTimeout",s.title,r.elapsedMs,r.timeoutMs)):(this.runResults.totalFailures++,this.runResults.failureInfo.push({describeChain:t.titleChain,title:s.title,error:r}),this.eventEmitter.emit("testFail",s.title,r,Date.now()-i)),this.config.stopOnFirstFail&&(this.testRunCancelled=!0)}).then(()=>this.evaluateQueueWithTimeout("afterEach")).then(()=>{this.runResults.totalTests++,this.currentTest=null}).catch(t=>{throw this.runResults.totalTests++,this.currentTest=null,t})})).then(()=>!0)}evaluateQueueWithTimeout(t){return this.timeoutPromisifier.wrap(this.evaluateQueue(t),this.getTimeoutValue(t))}evaluateQueue(t){const e=this.queueStacks[t];let s=Promise.resolve();if("before"===t||"beforeEach"===t)for(let t=0;t<e.length;t++){const i=e[t];for(let t=0;t<i.length;t++)s=s.then(()=>this.asyncPromisifier.exec(i[t]))}else for(let t=e.length-1;t>=0;t--){const i=e[t];for(let t=i.length-1;t>=0;t--)s=s.then(()=>this.asyncPromisifier.exec(i[t]))}return s}getTimeoutValue(t){return"number"==typeof this.config.timeoutMs?this.config.timeoutMs:this.config.timeoutMs[t]}}export{h as TestRunner};
